<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Driver Dashboard â€” AI Eco Driving</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>
<style>
body {
  margin: 0;
  font-family: "Poppins", sans-serif;
  background: #0d1117;
  color: #fff;
  overflow: hidden;
}
.dashboard {
  display: flex;
  height: 100vh;
  width: 100vw;
}
.left-panel {
  width: 20%;
  display: flex;
  flex-direction: column;
  padding: 10px;
  background: #161b22;
  overflow-y: auto;
}
.right-panel {
  width: 80%;
  display: flex;
  flex-direction: column;
  position: relative;
}
.card {
  background: #1e252f;
  padding: 10px;
  margin: 6px 0;
  border-radius: 12px;
  box-shadow: 0 0 5px #0008;
  text-align: center;
}
.card h2 {
  font-size: 1rem;
  margin-bottom: 6px;
  color: #58a6ff;
}
#aiTip { flex: 1; }
#map, #camera {
  flex: 1;
  border-radius: 12px;
  margin: 5px;
}
#map { height: 50%; }
#camera { height: 50%; background: #000; }
.search-container {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 6px 0;
}
.search-container input {
  width: 80%;
  padding: 8px;
  border: none;
  border-radius: 8px 0 0 8px;
  outline: none;
}
.search-container button {
  width: 20%;
  padding: 8px;
  border: none;
  border-radius: 0 8px 8px 0;
  background: #58a6ff;
  color: white;
  cursor: pointer;
}
#routePanel {
  max-height: 30vh;
  overflow-y: auto;
  margin-top: 10px;
}
.route-box {
  background: #1e252f;
  margin: 5px 0;
  padding: 8px;
  border-radius: 8px;
  box-shadow: 0 0 4px #0006;
}
.route-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  font-weight: 600;
}
.remove-btn {
  background: #ff4c4c;
  border: none;
  color: #fff;
  border-radius: 50%;
  width: 22px;
  height: 22px;
  cursor: pointer;
}

/* ===== Portrait Layout ===== */
@media (orientation: portrait) {
  .dashboard {
    flex-direction: column;
  }
  .left-panel, .right-panel {
    width: 100%;
  }
  .left-panel {
    flex-direction: column;
    align-items: center;
  }
  #aiTip {
    width: 95%;
    text-align: center;
  }
  .upper-row {
    display: flex;
    justify-content: space-around;
    width: 95%;
  }
  .middle-row {
    display: flex;
    justify-content: space-around;
    width: 95%;
  }
  .search-container {
    width: 95%;
    margin-top: 8px;
  }
  .right-panel {
    height: 100%;
  }
  #map, #camera {
    width: 95%;
    margin: auto;
    height: 35vh;
  }
}
</style>
</head>
<body>
<div class="dashboard">
  <div class="left-panel">
    <div id="aiTip" class="card"><h2>AI Tip</h2><p>Drive Smoothly</p></div>
    <div class="upper-row">
      <div id="speedCard" class="card"><h2>Speed</h2><p>0 km/h</p></div>
      <div id="gearCard" class="card"><h2>Gear</h2><p>N</p></div>
    </div>
    <div class="middle-row">
      <div id="throttleCard" class="card"><h2>Throttle</h2><p>0%</p></div>
      <div id="fuelCard" class="card"><h2>Fuel Used</h2><p>0.0 L</p></div>
    </div>
    <div class="search-container">
      <input type="text" id="searchBox" placeholder="Search location...">
      <button id="micButton">ðŸŽ¤</button>
    </div>
    <div id="routePanel"></div>
  </div>

  <div class="right-panel">
    <div id="map"></div>
    <div id="camera">Camera Feed</div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
<script>

/* ===== Map & Icons ===== */
const map = L.map('map').setView([19.076, 72.8777], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap'
}).addTo(map);

let driverMarker = L.marker([19.076, 72.8777]).addTo(map);
let waypoints = [];
let waypointMarkers = [];
let routes = [];
const colors = ['#00FF88','#0099FF','#FFCC00','#FF6699'];

/* ===== Eco Advisor ===== */
function ecoAdvisor(dist,elev,turnText){
    const t=(turnText||'').toLowerCase();
    let tip="Drive smoothly", speed=50, gear=3, throttle=45;

    // Road type detection
    const roadType=t.includes("highway")?"highway":
                   t.includes("city")?"city":
                   t.includes("roundabout")?"roundabout":"normal";

    if(t.includes("left")||t.includes("right")) { speed=25; gear=2; throttle=35; tip="Slow for turn"; }
    else if(elev>6) { speed=30; gear=2; throttle=55; tip="Uphill â€” maintain torque"; }
    else if(elev<-6){ speed=55; gear=5; throttle=25; tip="Downhill â€” coast gently"; }
    else if(dist>800){ speed=65; gear=5; throttle=50; tip="Long straight â€” steady speed"; }
    else if(dist>300){ speed=55; gear=4; throttle=45; tip="Smooth cruising"; }

    // Adjustments by road type
    if(roadType==="highway"){ speed=Math.min(speed,80); gear=Math.max(gear,5); throttle=50; tip+=" â€” highway"; }
    else if(roadType==="city"){ speed=Math.min(speed,50); gear=Math.min(gear,3); throttle=40; tip+=" â€” city"; }
    else if(roadType==="roundabout"){ speed=25; gear=2; throttle=35; tip+=" â€” roundabout"; }

    // Fuel saving hints
    if(speed>70) tip="High speed â€” reduce for fuel saving";
    if(throttle>60 && elev>3) tip="High throttle uphill â€” shift earlier";

    return {speed, gear, throttle, tip};
}

/* ===== Driver Behavior Monitoring ===== */
let driverStats={overspeed:0, harshAccel:0, totalPoints:0};
function updateDriverBehavior(currentSpeed,eco){
    driverStats.totalPoints++;
    if(currentSpeed>eco.speed+5) driverStats.overspeed++;
    
    const lastThrottle=document.getElementById("throttle").dataset.lastThrottle||0;
    const currentThrottle=eco.throttle;
    if(Math.abs(currentThrottle-lastThrottle)>25) driverStats.harshAccel++;
    document.getElementById("throttle").dataset.lastThrottle=currentThrottle;

    if(driverStats.overspeed/driverStats.totalPoints>0.3) eco.tip+=" â€” Slow down! Overspeed habit detected";
    if(driverStats.harshAccel/driverStats.totalPoints>0.2) eco.tip+=" â€” Smooth throttle for fuel saving";
}

/* ===== Elevation API ===== */
async function getElevations(coords){
    try{
        const locs=coords.map(p=>`${p.lat},${p.lng}`).join('|');
        const r=await fetch(`https://api.open-elevation.com/api/v1/lookup?locations=${encodeURIComponent(locs)}`);
        const d=await r.json();
        return d.results.map(x=>x.elevation);
    }catch{return new Array(coords.length).fill(0);}
}


/* ===== Multi-Step Route Awareness ===== */
async function getUpcomingSteps(latlng, maxSteps=5){
  if(!routes.length) return [];
  const upcomingSteps=[];
  routes.forEach(r=>{
    let nearestIdx=-1, minDist=Infinity;
    r.steps.forEach((s,i)=>{
      const d=latlng.distanceTo([s.lat,s.lng]);
      if(d<minDist){ minDist=d; nearestIdx=i; }
    });
    if(nearestIdx!==-1){
      for(let j=nearestIdx; j<Math.min(r.steps.length, nearestIdx+maxSteps); j++){
        upcomingSteps.push(r.steps[j]);
      }
    }
  });
  return upcomingSteps;
}

async function adaptiveAIDashboard(latlng,heading){
    const currentSpeed = calculateGPSSpeed(latlng);
    const slopeData=await predictElevation(latlng,heading);
    const slope=slopeData.slope;

    let eco={speed:50,gear:3,throttle:45,tip:"Drive smoothly"};

    if(routes.length){
        // Predict 3â€“5 steps ahead based on route steps
        const upcomingSteps=[];
        routes.forEach(r=>{
            r.steps.forEach(s=>{ const d=latlng.distanceTo([s.lat,s.lng]); if(d<500) upcomingSteps.push(s); });
        });
        upcomingSteps.slice(0,5).forEach(step=>{
            const stepSlope=step.elev-recentElevations[0]||slope;
            const stepEco=ecoAdvisor(step.distance,stepSlope,step.text);
            eco=stepEco; // adopt last relevant step for dashboard
            if(step.element) step.element.title=`Tip: ${stepEco.tip}, Speed: ${stepEco.speed}, Gear: ${stepEco.gear}, Throttle: ${stepEco.throttle}%`;
        });
    }

    updateDriverBehavior(currentSpeed,eco);

    document.getElementById("speed").textContent = eco.speed+" km/h";
    document.getElementById("gear").textContent = eco.gear;
    document.getElementById("throttle").textContent = eco.throttle+"%";
    document.getElementById("ai-tip").textContent = eco.tip;
    totalFuel += (eco.throttle/1000);
    document.getElementById("fuel-used").textContent = totalFuel.toFixed(2)+" L";
}

/* ===== GPS speed and idle detection ===== */
let lastLatLng=null, lastGPSPos=null, lastGPSTime=null, idleStart=null;
const IDLE_THRESHOLD=3, IDLE_TIME=60;
function checkIdle(latlng){
    if(!lastLatLng){ lastLatLng=latlng; idleStart=Date.now(); return false; }
    const dist=latlng.distanceTo(lastLatLng);
    if(dist<IDLE_THRESHOLD){ if(!idleStart) idleStart=Date.now(); return (Date.now()-idleStart)/1000 >= IDLE_TIME; }
    lastLatLng=latlng; idleStart=null; return false;
}
function calculateGPSSpeed(latlng){
    const now=Date.now();
    if(lastGPSPos && lastGPSTime){
        const dist=latlng.distanceTo(lastGPSPos);
        const dt=(now-lastGPSTime)/1000;
        lastGPSPos=latlng; lastGPSTime=now;
        return (dist/dt)*3.6;
    }else{ lastGPSPos=latlng; lastGPSTime=now; return 0; }
}

/* ===== Predict multi-step elevation ahead ===== */
const ELEVATION_LOOKAHEAD=5, ELEVATION_STEP=10;
let recentElevations=[];
async function predictElevation(latlng,heading){
    const R=6378137, pointsAhead=[];
    for(let i=1;i<=ELEVATION_LOOKAHEAD;i++){
        const d=ELEVATION_STEP*i;
        const latRad=latlng.lat*Math.PI/180;
        const lonRad=latlng.lng*Math.PI/180;
        const newLat=latRad+(d*Math.cos(heading*Math.PI/180))/R;
        const newLng=lonRad+(d*Math.sin(heading*Math.PI/180))/(R*Math.cos(latRad));
        pointsAhead.push({lat:newLat*180/Math.PI,lng:newLng*180/Math.PI});
    }
    const elevs=await getElevations(pointsAhead);
    recentElevations=elevs;
    const smoothSlope = elevs.reduce((a,b,i,arr)=>i===0?a: a + (b-arr[i-1]),0)/(elevs.length-1);
    const throttleCurve=elevs.map((e,i)=>{ const delta=i===0?0:e-elevs[i-1]; return delta>3?60: delta<-3?25:45; });
    return {elevs, slope:smoothSlope, throttleCurve};
}
/* ===== GPS Watch ===== */
if(navigator.geolocation){
    navigator.geolocation.watchPosition(async pos=>{
        const latlng=L.latLng(pos.coords.latitude,pos.coords.longitude);
        const heading=pos.coords.heading||0;
        if(!waypoints.length) waypoints.push(latlng); else waypoints[0]=latlng;
        if(!userMarker){ userMarker=L.marker(latlng,{icon:carIcon}).addTo(map); map.setView(latlng,14); }
        else userMarker.setLatLng(latlng);
        await adaptiveAIDashboard(latlng,heading);
        checkOffRoute(latlng);
    },()=>console.warn("GPS unavailable"),{enableHighAccuracy:true});
}

/* ===== Off-route adaptation ===== */
let lastRecalcTime = 0;
async function checkOffRoute(latlng) {
  if (!routes.length) return;

  const nearestRoute = routes[0];
  let minDist = Infinity;
  nearestRoute.steps.forEach(s => {
    const d = latlng.distanceTo([s.lat, s.lng]);
    if (d < minDist) minDist = d;
  });

  // Recalculate route only if far off and at least 10 seconds have passed
  if (minDist > 50 && Date.now() - lastRecalcTime > 10000) {
    console.log("Off-route detected â€” recalculating");
    lastRecalcTime = Date.now();

    const dest = waypoints[waypoints.length - 1];
    if (dest) {
      clearAllRoutes(); // remove old ones before creating new
      createRoute(latlng, dest, colors[routes.length % colors.length]);
    }
  }
}
/* ===== Route creation & step-box integration ===== */
async function createRoute(start, end, color) {
  const existing = routes.find(r =>
    Math.abs(r.end.lat - end.lat) < 0.0001 && Math.abs(r.end.lng - end.lng) < 0.0001
  );
  if (existing) return;

  const routeColor = color || colors[routes.length % colors.length];
  const rc = L.Routing.control({
    waypoints: [start, end],
    router: L.Routing.osrmv1({ serviceUrl: 'https://router.project-osrm.org/route/v1' }),
    show: false, addWaypoints: false, createMarker: () => null,
    lineOptions: { styles: [{ color: routeColor, weight: 5, opacity: 0.9 }] }
  }).addTo(map);

  const group = L.layerGroup().addTo(map);
  const box = document.createElement("div");
  box.className = "route-box";
  const header = document.createElement("div");
  header.className = "route-header";
  header.style.background = routeColor;
  header.innerHTML = `<b>Route ${routes.length+1}</b><button class="remove-btn">âœ•</button>`;
  const content = document.createElement("div");
  content.className = "route-content";
  content.style.display = "block";
  box.appendChild(header); box.appendChild(content);
  document.getElementById("routePanel").appendChild(box);

  header.onclick = e => { if (!e.target.classList.contains("remove-btn")) content.style.display = content.style.display === "block" ? "none" : "block"; };
  header.querySelector(".remove-btn").onclick = e => { e.stopPropagation(); removeRoute(rc); };

  rc.on("routesfound", e => {
    const route = e.routes[0];
    routes.push({ rc, group, end, box, color: routeColor });
  });
}
  
// ================== SPEECH RECOGNITION ==================
let recognition;
if ('webkitSpeechRecognition' in window) {
  recognition = new webkitSpeechRecognition();
  recognition.lang = 'en-IN';
  recognition.onresult = function(event) {
    const speechResult = event.results[0][0].transcript;
    document.getElementById("searchBox").value = speechResult;
    searchLocation(speechResult);
  };
}

document.getElementById("micButton").addEventListener("click", () => {
  if (recognition) recognition.start();
  else alert("Speech recognition not supported in this browser.");
});

// ================== SEARCH LOCATION ==================
function searchLocation(query) {
  fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`)
    .then(res => res.json())
    .then(data => {
      if (data && data.length > 0) {
        const loc = data[0];
        const latlng = [parseFloat(loc.lat), parseFloat(loc.lon)];
        createRoute(driverMarker.getLatLng(), {lat: latlng[0], lng: latlng[1]}, '#00FF88');
        map.setView(latlng, 13);
      } else {
        alert("Location not found!");
      }
    });
}
/* ===== Add waypoint on map click ===== */
map.on('click',e=>{
    const latlng=e.latlng; waypoints.push(latlng);
    const marker=L.marker(latlng).addTo(map); waypointMarkers.push(marker);
    if(waypoints.length>=2) createRoute(waypoints[waypoints.length-2],latlng,colors[routes.length%colors.length],marker);
});

// ================== ROUTE MANAGEMENT ==================
function removeRoute(rc) {
  const i = routes.findIndex(r => r.rc === rc);
  if (i !== -1) {
    const r = routes[i];
    map.removeControl(r.rc);
    map.removeLayer(r.group);
    if (r.box && r.box.parentNode) r.box.parentNode.removeChild(r.box);
    routes.splice(i, 1);
    renumberRouteBoxes();
  }
}

function renumberRouteBoxes() {
  const boxes = document.querySelectorAll(".route-header b");
  boxes.forEach((b, i) => b.innerText = `Route ${i+1}`);
}

function clearAllRoutes() {
  routes.forEach(r => {
    map.removeControl(r.rc);
    map.removeLayer(r.group);
    if (r.box && r.box.parentNode) r.box.parentNode.removeChild(r.box);
  });
  routes = [];
  document.getElementById("routePanel").innerHTML = "";
}

/* ===== Rebuild Routes ===== */
function rebuildRoutes() {
  clearAllRoutes();
  if (waypoints.length < 2) return;
  for (let i = 1; i < waypoints.length; i++) {
    createRoute(
      waypoints[i - 1],
      waypoints[i],
      colors[(i - 1) % colors.length],
      waypointMarkers[i - 1],
      i
    );
  }
}

/* ===== Map Toggle ===== */
let mapFull=false;
document.getElementById("map-toggle").addEventListener("click",()=>{
  const mapContainer=document.querySelector(".map-container");
  const camera=document.querySelector(".camera");
  const button=document.getElementById("map-toggle");
  if(!mapFull){
    mapContainer.style.position="fixed"; mapContainer.style.top="0"; mapContainer.style.left="0"; mapContainer.style.width="100vw"; mapContainer.style.height="100vh"; mapContainer.style.zIndex="2000";
    camera.style.display="none"; button.innerText="Restore Map"; mapFull=true; setTimeout(()=>map.invalidateSize(),300);
  }else{
    mapContainer.style.position=""; mapContainer.style.width=""; mapContainer.style.height=""; mapContainer.style.zIndex="";
    camera.style.display="block"; button.innerText="Full Map"; mapFull=false; setTimeout(()=>map.invalidateSize(),300);
  }
});

/* ===== Camera Toggle ===== */
const camImg=document.getElementById("camera-feed");
document.getElementById("enable-camera").onclick=()=>{ camImg.style.filter="none"; document.getElementById("enable-camera").style.display="none"; document.getElementById("disable-camera").style.display="block"; }
document.getElementById("disable-camera").onclick=()=>{ camImg.style.filter="blur(12px) brightness(0.7)"; document.getElementById("enable-camera").style.display="block"; document.getElementById("disable-camera").style.display="none"; }

/* ===== Search UI ===== */
const input=document.getElementById('searchInput'),suggestBox=document.getElementById('suggestBox');
let results=[];
input.oninput=async()=>{
  const q=input.value.trim(); if(!q) return suggestBox.style.display='none';
  const d=await fetch(`https://photon.komoot.io/api/?q=${encodeURIComponent(q)}&limit=6`).then(r=>r.json()).catch(()=>({features:[]})); results=d.features||[];
  suggestBox.innerHTML=''; results.forEach((f,i)=>{ const p=f.properties||{},name=p.name||p.city||'Unknown'; const div=document.createElement('div'); div.className='suggest-item'; div.innerHTML=`<b>${name}</b><div style="font-size:12px;color:#bbb;">${[p.city,p.state,p.country].filter(Boolean).join(', ')}</div>`; div.onclick=()=>select(i); suggestBox.appendChild(div); });
  suggestBox.style.display=results.length?'block':'none';
};
document.addEventListener('click',e=>{if(!suggestBox.contains(e.target)&&e.target!==input) suggestBox.style.display='none';});
document.getElementById('addBtn').onclick=()=>{if(results.length) select(0);};
input.addEventListener('keydown',e=>{if(e.key==='Enter'&&results.length) select(0);});
function select(i){ const f=results[i]; if(!f) return; const [lng,lat]=f.geometry.coordinates,latlng=L.latLng(lat,lng); waypoints.push(latlng); L.marker(latlng).addTo(map); suggestBox.style.display='none'; input.value=''; if(waypoints.length>=2) createRoute(waypoints[waypoints.length-2],latlng,colors[routes.length%colors.length]); }
</script>
</body>
</html>


